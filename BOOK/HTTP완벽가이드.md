
## HTTP 완벽 가이드 
![http완벽가이드](https://user-images.githubusercontent.com/46988995/88808489-e9e86f80-d1ed-11ea-80cc-b9b06fe49905.jpg)
### 목차
+ [1. 웹의 기초](#1.-웹의-기초)
    + [1-1) HTTP 개관](#http-개관)
    + [1-2) URL과 리소스](#URL과-리소스)
    + [1-3) HTTP 메시지](#HTTP-메시지)
    + [1-4) 커넥션 관리](#커넥션-관리)
+ [2. HTTP 아키텍처](#2.-HTTP-아키텍처)
    + [2-1) 웹서버](#웹서버)
    + [2-2) 프락시](#프락시)

- - -
## 1. 웹의 기초
### HTTP 개관
+ **웹 클라이언트와 서버**
    + 웹 서버는 HTTP 프로토콜로 의사소통 → HTTP 서버라고도 불린다.
    + 클라이언트 → HTTP 요청(Request) → 서버
    + 서버 → HTTP 응답(Response) -> 클라이언트
    
+ **웹 리소스**
    + 웹 서버는 웹 리소스를 관리하고 저장한다. (웹 컨텐츠)
    + 리소스는 정적(Static)파일일 수도 있고, 동적 파일일 수도 있다.
    
+ **미디어타입(MIME)**
    + HTTP는 웹에서 전송되는 객체 각각에 MIME 타입이라는 데이터 포맷 라벨을 붙인다. (대부분의 웹브라우저에서 지원)
    + 수 많은 데이터 타입(영상, 텍스트, 이미지 등등..)을 효율적으로 다루기 위해 필요로 한다.
+ **URI(Uniform Resource Identifier)**
    + 리소스별 식별자 같은 개념이다.
    + URI에는 URL과 URN이 있다.
+ **HTTP 메소드**
    | Method | Description |
    | ------ | ----------- |
    | GET | 서버에서 클라이언트로 지정한 리소스를 전송 |
    | PUT | 클라이언트에서 서버로 보낸 데이터를 특정 이름의 리소스로 전송 |
    | DELETE | 지정한 리소스를 서버에서 삭제 |
    | POST | 클라이언트 데이터를 서버 게이트웨이 애플리케이션으로 전송 |
    | HEAD | 지정한 리소스에 대한 응답에서, 헤더 값만 전송 |

+ **HTTP 상태코드**
    + 모든 HTTP 응답 메시지는 상태 코드와 함께 반환ㄱㄱ
        | Code | Description |
        | ------ | ----------- |
        | 200 | 올바르게 반환 |
        | 302 | 재전송 요청, 다른 곳에 있는 리소스를 반환하도록 요청 |
         | 404 | 리소스를 찾을 수 없음 |
    
+ **TCP 커넥션**
    + HTTP 메시지를 주고받은 과정
        1. 웹브라우저는 서버의 URL에서 호스트 명을 추출
        2. 웹브라우저는 서버의 호스트명을 IP주소로 반환
        3. 웹브라우저는 URL에서 포트번호를 추출(없다면 기본 값 80)
        4. 웹브라우저는 웹 서버와 TCP 커넥션을 맺음
        5. 웹브라우저는 서버에 HTTP 요청 → 서버는 웹브라우저에게 HTTP 응답
        6. 커넥션이 닫히고 웹브라우저는 문서(리소스)를 출력

+ **웹의 구성요소**
    - 프락시서버
        + 클라이언트와 서버 중간에 위치, 클라이언트의 모든 HTTP 요청을 받아 전달
        + 웹 트래픽 속에서 신뢰할만한 중개자 역할(보안)
    - 캐시
        + 웹 서버보다 더 빨리 리소스를 가져오기 위해 저장하는 리소스의 사본
        + 웹 캐시, 프락시 캐시
    - 게이트웨이
        + 다른 서버들의 중개자로 동작하는 서버
        + HTTP 트래픽을 다른 프로토콜로 변환
### URL과 리소스
+ **URL(Uniform Resource Locator)**
    + 인터넷의 리소스를 가리키는 표준이름
    + 웹 브라우저가 정보를 찾는데 필요한 리소스의 위치를 가리킴
    
+ **URL의 구조**
    + `스킴://서버위치/경로` 구조로 이루어져 있다.
    + 이러한 구조를 가지게되면서 브라우저가 더 영리하게 리소스에 접근하고 다룰 수 있게 되었다.

+ **URL 문법**
    + 필자의 깃 주소를 예를 들면
        + > https://github.com/yondo123/
            + 스킴 : 어떤 프로토콜을 사용할 것인지? → https
                + 스킴은 대소문자를 가리지 않는다.
            + 사용자 이름 : 보통 `ftp` 프로토콜에서 사용한다 (기본 값 : anonymous)
            + 호스트 : 리소스를 호스팅하는 서버의 호스트명 또는 IP 주소 → github.com
            + 포트 : 호스팅하는 서버가 열어놓은 포트번호  → 깃허브 https의 기본 포트번호는 443이다. (http는 80)
            + 경로 : 서버 내 리소스가 어디에 있는지?  → /yondo123
            + 질의어 : 요청받은 리소스 형식의 범위를 좁히기 위해 사용
                > /search/all?frm=NVSHPRC&maxPrice=40000&minPrice=20000&minPrice-maxPrice=20000-40000 (흔한 쇼핑몰 질의 방식)
            + 보통 '&'로 구분하여 `'key=value'` 형식으로 많이 사용한다. 
    
    + **URL 확장**
    + 브라우저 마다 URL을 입력한 다음 자동으로 URL을 확장(생성) 해주는 기능
    1. 호스트명 확장
        + 호스트명만 입력하면 자동으로 'www'와 'com'을 붙여서 URL을 생성한다.
    2. 히스토리 확장
        + 사용자가 과거에 방문했던 URL의 기록을 저장하고 자동으로 URL을 선택해주게 하는 것

+ **안전한 전송**
    + 정보가 유실될 위험 없이 URL을 전송할 수 있다.
    + RFC 2396 (URI 포맷 정의 기관)에서는 어플리케이션이 공백을 무시하기를 권고하고 있다.
    + **인코딩 체계**
        - URL에 있는 안전하지 않은 문자들을 표현할 수 있는 인코딩 방식 고안
        - 안전하지 않은 문자를 '%'기호 + ASCII코드의 16진수 이스케이프 문자를 합쳐 바꾼다.
            | Char | ASCII | URL |
            | ------ | ----------- | ------| 
            | ~ | 26(0x7E) | /%7E |
            | 공백 | 32(0x20) | /%20 |
            | % | 37(0x25) | /%25 |
    
+ **문자 제한**
    + URL에서 흔히 사용하는 문자(예약어)를 본래의 용도가 아닌 다른 용도로 사용하는 경우, 반드시 인코딩 해야 한다.
        | Char | 제한 |
        | --- | --- |
        | % | 인코딩된 문자에 사용할 이스케이프 토큰 |
        | / | 경로 컴포넌트에있는 경로 세그먼트를 나누는 용도 |
        | . | 경로 컴포넌트 |
        | .. | 경로 컴포넌트 |
        | # | 프래그먼트의 구획 문자 |
        | ? | 질의 문자열의 구획 문자  |
        | ; | 파라미터의 구획 문자 |
        | : | 스킴, 사용자이름/비밀번호, 호스트/포트의 구획 문자 |
        | $, + | 선점 |
        | @ & = | 특정 스킴에서 특별한 의미가 있음 |
        | {} `|`\ · ~ [] ` | 게이트웨이와 같은 여러 전송 에이전트에서 불안전하게 다루기 때문에 제한 |
        | <> " | URL을 구분지어 표시하듯이 URL 범위 밖에서 역할이 있는 문자이기 때문에 제한 |
        | 0x00-0x1F, 0x7F | US-ASCII에서 인쇄되지 않는 문자 범위 |
        | > 0x7F | 7비트의 US-ASCII 문자가 아니기 떄문에 제한 |
### HTTP 메시지
+ **인바운드와 아웃바운드**
    + 인바운드 : 메시지가 원 서버로 향하는 것
    + 아웃바운드 : 모든 처리가 끝난 후 사용자에게 다시 돌아오는 것
    + 메시지는 `원 서버 방향으로(인바운드)` 송신된다.
    
+ **메시지의 구성**
    + 시작줄, 헤더, 메시지(본문, 엔티티)로 구분된다.
    + 메시지 본문은 단순히 선택적인 데이터 덩어리이다.
    + 비어져있을 수 있고, 이진 데이터를 포함할 수 있다.

+ **메시지 문법**
    + HTTP 요청/응답 메시지 형태는 다음과 같다.
    + `시작줄 - 헤더 - 본문`으로 구성되어 있다.
        ```
                -Request 
                <Method> <요청 URL> <version>
                <header>
                <context>

                -Response
                <version> <status> <status comment>
                <header>
                <context>
        ```
    + 요청 URL
        + 요청 대상의 리소스 주소를 가리킨다.
        + URL에서 호스트/포트가 생략되면 서버에서 자기 자신으로 간주하고 통신한다.
    + 본문(context)
        + 임의의 데이터 블록, 선택사항이므로 만약 없다면 메시지는 CRLF으로 끝나게 된다.
        + 요청 메소드에 따라 본문이 필요할수도, 필요없을수도 있다.
    + 헤더
        + 애플리케이션 마다 자유롭게 자신만의 헤더를 만들어낼 수 있다.
    
+ **요청 메소드**
    | Method | Description | Text Y/N  | Remark |
    | ------ | ----------- | --|----|
    | GET    | 서버에서 어떤 문서(리소스)를 가져온다. | N | |
    | HEAD   | 서버에서 어떤 문서(리소스)에서 헤더만 가져온다. | N | 동작은 GET과 동일 |
    | POST   | 서버에서 처리해야 할 데이터를 보낸다.  | Y |  |
    | PUT    | 서버에 요청 메시지의 본문을 저장한다. | Y | 요청 본문이 없다면 리소스를 생성, 존재한다면 기존 리소스 수정 | 
    | TRACE  | 요청 메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적한다. | N | 진단을 위해 사용 |
    | OPTIONS| 서버가 어떤 메소드를 수행할 수 있는지 확인한다. | N | |
    | DELETE | 서버에서 문서를 제거한다. | N | 서버는 클라이언트에 통보하지 않고 요청을 무시 가능 |

+ **상태 코드**
    + 정보성 상태 코드 (100 ~ 199)
        + HTTP 1.1에서 도입
        + 100 : Continue (요청 받아들여짐)
        + 101 : Switching Protocols (서버가 프로토콜을 변경)

    + 성공 상태 코드 (200 ~ 299)
        | Status | Text | Description |
        | ---- | ---- | ---- |
        | 200  | OK | 정상요청, 요청한 리소스를 가지고 있다. |
        | 201  | Created | PUT 요청, 생성된 리소스에 대한 구체적 참조 메시지 필요 | 
        | 202 | Accepted | 요청은 받아들여졌으나, 서버 측에서 어떠한 동작도 수행하지 않음 |
        | 203 | Non-Authoritative Information | 중개자가 사본을 갖고 있지만 리소스에 대한 정보 검증 부족 |
        | 204 | No Content | 헤더와 상태줄은 포함하지만 본문을 포함하지 않을 때 (클라이언트에게 전송 할 데이터가 없음) |
        | 205 | Recent Content | 브라우저를 위한 코드, 현재 페이지에 있는 HTML 폼을 비우라는 요청 |
        | 206 | Partial Content | 부분 또는 범위 요청 성공 | 
        
    + 리다이렉션 상태 코드 (300 ~ 399)
        + 클라이언트가 요청하는 리소스에 대해 다른 위치를 제시하거나, 대안 응답을 제공한다.
        
    + 클라이언트 - 에러 상태 코드 (400 ~ 499)
        | Status | Text | Description |
        | ---- | ---- | ---- |
        | 400  | Bad Request | 잘못된 요청을 전송 |
        | 401  | Unauthorized | 리소스를 얻기전에 클라이언트에게 인증 요청 |
        | 402 | Payment Required  | 현재 사용안함 |
        | 403 | Forbidden | 서버에 의해 요청이 거부됨 |
        | 404 | Not Found | 요청한 URL을 서버가 찾을 수 없음 |
        | 405 | Method Not Allowed | 요청한 메소드에 대해 서버가 지원하지 않음 |
        | 408 | Request Timeout | 클라이언트 요청을 완수하기에 너무 시간이 길 경우 |

    + 서버 - 에러 상태 코드 (500 ~ 599)
        | Status | Text | Description |
        | ---- | ---- | ---- |
        | 500 | Internal Server Error | 서버가 요청을 처리할 수 없음 |
        | 501 | Not Implemented | 클라이언트가 서버가 지원하지 않는 메소드를 사용 (능력범위이상) |
        | 502 | Bad Gateway | 프락시나 게이트웨이처럼 행동하는 서버가 다음 링크로부터 가짜 응답에 맞닥뜨렸을 때 |
        | 503 | Service Unavailable | 현재는 서버가 처리할 수 없지만 추후 가능함 |
        | 504 | Gateway Timeout | 상태코드 '408'과 유사하지만, 다른 서버에게 요청을 보내고 응답을 기다리다 Timeout이 발생 (게이트웨이 또는 프락시에서 응답)|
        | 505 | HTTP Version Not Supported | 서버가 지원할 수 없거나 지원하지 않으려고하는 프로토콜 버전을 요청 받았을 때 |

### 커넥션 관리
+ **TCP 커넥션**
    + 모든 HTTP 통신은 `TCP/IP` 프로토콜을 통해 이루어진다.
    + 클라이언트 애플리케이션과 서버 애플리케이션은 언제 어디서든, TCP/IP 커넥션을 맺을 수 있다. 한번 맺어지면 메시지들은 손상되지 않고 올바르게 전달된다.

+ **HTTP와 HTTPS 네트워크 프로토콜**
    ![HTTPS/HTTP](https://user-images.githubusercontent.com/46988995/90979136-f1e9c400-e58d-11ea-89a8-c5be8e8edbaf.jpg)
    + HTTP가 메시지를 전달할 경우, TCP 커넥션을 통해 메시지 데이터를 순서대로 보내고 세그먼트라는 단위로 데이터 스트림을 분할 -> 세그먼트들을 패킷 단위로 인터넷을 통해 데이터를 전송한다.

+ **TCP 커넥션 유지**
    + TCP 커넥션의 식별 방법
        > <발신지 IP, 발신지 PORT, 수신지 IP, 수신지 PORT>
        + 네가지 커넥션 구성요소가 완전히 동일한 커넥션은 있을 수 없다.
    
+ **TCP 커넥션 성능 지연 요소**
    + TCP 커넥션의 핸드셰이크 설정
        + 커넥션을 새로 맺을 때 마다 SYN+ACK 플래그 값들의 핸드셰이크 지연이 발생한다.
    + TCP의 느린 시작 (slow-start)
        + TCP 커넥션은 시간이 흐를수록(데이터 교환) 전송 성공률에 따라 전송 속도를 높여나간다. 즉, 새로 맺은 커넥션보다 이미 연결중인 커넥션 속도가 더빠르며 커넥션 재사용을 통해 이 문제를 해결할 수 있다.
    + 네이글(nagle) 알고리즘
        + 크기가 작은 메시지는 최소 패킷을 채우지 못해 추가적인 데이터를 기다리며 지연될 것이다.

+ **커넥션 끊기**
    + HTTP 메시지는 클라이언트에서 서버로 전송하기 까지 많은 중개자 서버를 하나하나 거치면서 전송된다.

    + HTTP 커넥션 헤더 필드는 쉼표로 구분하고 있고 현재 맺고 있는 커넥션에서만 적용하는 옵션을 명시할 수 있다.
        + `Connection: close` 옵션은 메시지를 전송하고 즉시 종료하라는 의미의 옵션 값이다.

+ **커넥션 종류**
    + 순차 커넥션
        + 각 트랜잭션이 새로운 커넥션을 맺는 방식으로 새로운 커넥션을 맺을 때 마다 맺는데 발생하는 지연과 slow-start 지연이 발생하는 문제가 있다.
        + 이를 해결하기 위해 병렬, 지속, 파이프라인, 다중 커넥션 등의 성능 향상 기법이 있다.

    + 병렬 커넥션
        + 여러개의 HTTP 트랜잭션을 병렬적으로 처리하는 기법으로 커넥션 지연 시간을 겹치게해 더욱 빠르게 서버의 리소스를 로드할 수 있다.
        + 사실 리소스(웹 페이지)를 더 빠르게 로드하지 않더라도, 사용자에게는 동시에 여러 리소스를 받아오는 것을 보이게하면서 '더 빠르게' 느껴보이는 효과가 있다. 
        + 순차 커넥션보다 일반적으로 빠르긴 하지만, 항상 빠른것은 아니다, 클라이언트의 네트워크 대역폭이 좁을 때는 제한된 대역폭 내에서 각각 리소스를 전송받는 것은 느리기 때문에 성능상의 장점이 없는셈이다.
    
    + 지속 커넥션
        + 보통 한 웹 사이트에서 사용하는 자원은 한정적이어서 대부분의 리소스는 같은 공간(서버)를 가리킨다. 따라서 한 서버에 HTTP 통신을 요청한 애플리케이션은 동일한 서버에 요청 할 가능성이 크다.
        (이를 사이트 지역성, site locality라 부른다.)
        비 지속 커넥션은 각 처리(트랜잭션)이 끝날 때마다 커넥션을 끊고 새로 연결을 맺지만, 지속 커넥션은 클라이언트나 서버에서 끊기 전까지 트랜잭션 간에도 커넥션을 유지한다. 항상 서버에 이미 맺어진 커넥션을 재사용함으로써, 커넥션을 맺는데 걸리는 지연시간을 최소화할 수 있다.
        + HTTP/1.1에서는 커넥션을 맺으면 기본적으로 지속 커넥션으로 유지한다.
    
    + 파이프라인 커넥션
        + HTTP/1.1에서는 지속 커넥션을 이용해 요청을 파이프라이닝할 수 있다. 여려개의 요청은 응답이 도착하기 전 까지 큐에 쌓이고, 첫 요청이 서버측에 전달되면 연이어 두 번째, 세 번째 요청이 전달되는 방식이다. 이는 대기시간이 긴 네트워크 상황 속에서 왕복 지연 시간을 줄여 성능을 높여준다.

## 2. HTTP 아키텍처
### 웹서버
+ **웹서버가 하는일**
    + 커넥션 맺기
    + 요청받기 및 요청처리
    + 리소스 접근
    + response 생성 및 전송(올바른 헤더)
    + 로그파일 기록(트랜잭션 단위)
+ *HTTP 프로토콜 구현 및 웹 리소스, 웹 서버 관리 기능을 제공*

+ **커넥션 과정**
    1. 클라이언트가 웹서버에 TCP 커넥션을 요청한다.
    2. 웹서버는 TCP 커넥션으로 `IP`를 기준으로 어떤 클라이언트가 있는지 확인한다.
    3. 새 커넥션을 커넥션 목록에 추가하고 데이터 송수신 준비를 한다.

+ **Ident 프로토콜**
    + 서버에서 어떤 사용자가 커넥션을 초기화했는지 찾아낼 수 있는 프로토콜
    + Ident 프로토콜이 지원된다면, `113`포트를 통해 사용자 이름을 물을 수 있다.

+ **요청 메시지 수신**
    + 커넥션에 클라이언트가 보낸 메시지가 도착하면, 웹서버는 데이터를 파싱하여 요청메소드, 리소스 식별자(URI), HTTP 버전번호를 찾는다. 
    + HTTP 버전 번호를 지원하지 않는 경우, `HTTP 0.9` 버전으로 인식하고 처리한다.

+ **웹 서버 아키텍처**
    + 웹 서버 마다 아키텍처가 다르다. 
        1. **단일 스레드 웹 서버**
            + 한 번에 하나씩 요청을 처리
            + 처리 도중 다른 커넥션은 무시

        2. **멀티 스레드 웹 서버**
            + 여러개의 프로세스 또는 고효율 스레드를 할당한다.
            + 수 많은 프로새스나 스레드는 메모리 및 시스템 리소스를 소비하기 때문에 갯수 생성에 제한을 둔다.
        3. **다중 아키텍처**
            + 모든 커넥션은 활동 시 감시(detect) 당한다.
            + 한 커넥션의 처리가 종료되면, 다음 커낵션을 수행하기 위해 커넥션 목록으로 돌아가는 방식
            + 유휴 상태의 커넥션에 대기하기 때문에 리소스가 발생하지 않는다.
        
        4.  **다중 멀티스레드 웹 서버**
            + 웹서버 CPU의 이점을 효율적으로 사용하기 위해 멀티스레딩 방식과 다중화를 결합한 방식
            + 여러개의 다중 입출력 스레드를 배치해 각각 열려있는 스레드들을 감시하고 조금씩 작업을 수행한다.

+  **Docroot**
    + 웹서버 파일 시스템의 특정 디렉토리를 예약해두는 방식
    + 요청 메시지에서 찾을 URL을 바로 `Docroot`에 붙여 빠르게 리소스 접근이 가능하다.

+  **웹서버 디렉토리**
    + 만약 요청 경로가 리소스가 아닌 디렉토리 목록을 요청할 경우 몇가지 대응 방식이 있다.
        1. 에러 페이지 반환 (접근 금지)
        2. 툭별한 색인파일(Index) 반환
            + 아파치에서는 `DirectoryIndex` 지시자를 이용해 색인 파일로 이용할 수 있는 리소스를 설정할 수 있다.
        3. 디렉토리 목록을 탐색해 내용을 담은 HTML파일 반환
            + 일반적으로 접근 할 수 없는 리소스들도 노출된다는 단점이 있다.

+ **응답 만들기**
    + 웹서버에서 리소스를 탐색하면, 클라이언트에게 응답 메시지를 전달해야한다.
    + 응답 엔터티가 필수는 아니지만 만약 보내야한다면, 보통 다음의 내용을 포함한다.
        + 응답 본문의 MIME 타입을 서술하는 `Content-Type`
        + 응답 본문의 길이를 서술하는 `Content-length`
        + 응답 본문의 내용 `body`
    
    + MIME 타입 결정
        + 응답 본문의 MIME 타입을 알아내기 위해 여러가지 방법이 있다.
            1. 확장자 검사
                + 간단하게 리소스의 확장자를 검사하는 방법이다.
            2. 매직 타이핑 
                + 각 파일의 내용을 검사해 패턴에 대한 테이블을 생성하여 Content 파일을 검사한다.
                + 느린 방법이다.. (표준화 되어있지 않는 리소스에 효과적)
            3. 유한 명시
                + 특정 파일이나 디렉토리 안의 파일들이 확장자나 내용에 상관없이 특정 MIME타입을 갖게 설정할 수 있다.
            4. 유한 협상
                + 특정 파일이 특정 MIME 타입을 갖게하거나, 여러 문서 형식에 속하도록 설정할 수 있다.
    
+ **리다이렉션**
    + 웹서버는 성공 메시지 대신 리다이렉션 응답을 반환하는 경우가 있다.
    + 301 Moved Permanently
        + 새 URL이 부여되어 새로운 위치로 옮기거나 이름이 바뀌었을 경우
    + 303 See Other, 307 Temporary Redirect
        + 임시로 리소스가 옮겨진 경우
    
### 프락시
+ **프락시**
    + 클라이언트와 서버(원서버) 사이에서 중개자 역할 수행

+ **개인 프락시와 공용 프락시**
    + 개인 프락시 : 하나의 클라이언트를 위한 프락시
    + 공용 프락시 : 공유된 프락시, 공유된 다수의 클라이언트들의 요청에 기반한 효율성 장점

+ **프락시를 사용하는 이유**
    1. 보안 개선
        + 필터링 프락시 : 악성 컨텐츠 식별, 응답 차단
        + 클라이언트 별 접근 제어 관리
        + 보안 방화벽 구성, 익명화 프락시

    2. 성능 효율, 비용 감소
        + 프락시 웹캐시 : 자주 접근하는 웹 문서의 로컬 사본 관리, 인터넷 커메뉴케이션 감소
        + 트래픽 조건과 컨텐츠 종류에 따라 효율적인 요청 `(복제 캐시)` 
        + 트랜스 코딩 : 클라이언트 환경에 따른 데이터 압축, 형변환 가능
    
+ **프락시의 위치**
    + 출구(Egress) 
        + 로컬 네트워크의 출구 위치 (보안 방화벽, 트래픽 성능 개선)
        + 컨텐츠 차단 (특정 클라이언트)
    + 접근 프락시
        + ISP 접근 지점 (모든 클라이언트 요청 처리에 적함)
        + 다운로드 속도 개선, 대역폭 관리
    + 대리 프락시 (리버스 프락시)
        + 원 웹서버 바로 앞 위치 (웹서버로 향하는 모든 요청을 처리)
        + 웹서버의 IP, 이름을 따라가기 때문에 모든 요청은 이 프락시에게 전달
+ **프락시 계층**
    + 연쇄 프락시 구성 가능 (원 서버로 가기 까지 프락시에서 프락시 사이 이동)
    + 프락시 계층에서 프락시 서버들은 부모 <-> 자식 관계 유지

    + 동적 부모 선택
        - 부하 균형 : 부모들의 작업량 수준에 근거하여 선택
        - 지리적 인접성 : 원서버의 지역을 담당하는 부모 선택
        - 프로토콜/타입 라우팅 : 특정  URI를 보유했을 때 지정한 프락시로 이동
+ **부분 URI를 받게됨으로써 일어날 수 있는일**
    + 일반적으로 웹서버와 클라이언트에서 클라이언트는 부분 URI를 보낸다.
    + 프락시는 원서버와 커넥션을 맺어야하기 때문에, 원 서버의 정보가 필요하다.`(완전한 URI 필요)`

    1. 완전한 URI : 그냥 사용
    2. 부분 URI와 호스트 헤더 : 호스트 헤더를 사용해 원서버 정보 추출
    3. 부분 URI
        + 대리 프락시 : 프락시 자체에서 원서버 설정 정보 보유
        + 이너럽트 프락시 : 이전 인터럽트 프락시 커넥션 기록 참고
    4. URI, 호스트헤더 미수신 : 오류 메시지 반환

+ **Via 헤더**
    + 메시지가 지나는 각 노드의 정보`(프락시 또는 게이트웨이)`를 나열한다.
    + 프락시에서 네트워크 탐지 역할로 사용한다.
