
## HTTP 완벽 가이드 
![http완벽가이드](https://user-images.githubusercontent.com/46988995/88808489-e9e86f80-d1ed-11ea-80cc-b9b06fe49905.jpg)
### 목차
+ [1. 웹의 기초](#1.-웹의-기초)
    + [1-1) HTTP 개관](#http-개관)
    + [1-2) URL과 리소스](#URL과-리소스)
    + [1-3) HTTP 메시지](#HTTP-메시지)
    + [1-4) 커넥션 관리](#커넥션-관리)
+ [2. HTTP 아키텍처](#2.-HTTP-아키텍처)
    + [1-1) 웹서버](#웹서버)

- - -
## 1. 웹의 기초
### HTTP 개관
+ **웹 클라이언트와 서버**
    + 웹 서버는 HTTP 프로토콜로 의사소통 → HTTP 서버라고도 불린다.
    + 클라이언트 → HTTP 요청(Request) → 서버
    + 서버 → HTTP 응답(Response) -> 클라이언트
    
+ **웹 리소스**
    + 웹 서버는 웹 리소스를 관리하고 저장한다. (웹 컨텐츠)
    + 리소스는 정적(Static)파일일 수도 있고, 동적 파일일 수도 있다.
    
+ **미디어타입(MIME)**
    + HTTP는 웹에서 전송되는 객체 각각에 MIME 타입이라는 데이터 포맷 라벨을 붙인다. (대부분의 웹브라우저에서 지원)
    + 수 많은 데이터 타입(영상, 텍스트, 이미지 등등..)을 효율적으로 다루기 위해 필요로 한다.
+ **URI(Uniform Resource Identifier)**
    + 리소스별 식별자 같은 개념이다.
    + URI에는 URL과 URN이 있다.
+ **HTTP 메소드**
    | Method | Description |
    | ------ | ----------- |
    | GET | 서버에서 클라이언트로 지정한 리소스를 전송 |
    | PUT | 클라이언트에서 서버로 보낸 데이터를 특정 이름의 리소스로 전송 |
    | DELETE | 지정한 리소스를 서버에서 삭제 |
    | POST | 클라이언트 데이터를 서버 게이트웨이 애플리케이션으로 전송 |
    | HEAD | 지정한 리소스에 대한 응답에서, 헤더 값만 전송 |

+ **HTTP 상태코드**
    + 모든 HTTP 응답 메시지는 상태 코드와 함께 반환ㄱㄱ
        | Code | Description |
        | ------ | ----------- |
        | 200 | 올바르게 반환 |
        | 302 | 재전송 요청, 다른 곳에 있는 리소스를 반환하도록 요청 |
         | 404 | 리소스를 찾을 수 없음 |
    
+ **TCP 커넥션**
    + HTTP 메시지를 주고받은 과정
        1. 웹브라우저는 서버의 URL에서 호스트 명을 추출
        2. 웹브라우저는 서버의 호스트명을 IP주소로 반환
        3. 웹브라우저는 URL에서 포트번호를 추출(없다면 기본 값 80)
        4. 웹브라우저는 웹 서버와 TCP 커넥션을 맺음
        5. 웹브라우저는 서버에 HTTP 요청 → 서버는 웹브라우저에게 HTTP 응답
        6. 커넥션이 닫히고 웹브라우저는 문서(리소스)를 출력

+ **웹의 구성요소**
    - 프락시서버
        + 클라이언트와 서버 중간에 위치, 클라이언트의 모든 HTTP 요청을 받아 전달
        + 웹 트래픽 속에서 신뢰할만한 중개자 역할(보안)
    - 캐시
        + 웹 서버보다 더 빨리 리소스를 가져오기 위해 저장하는 리소스의 사본
        + 웹 캐시, 프락시 캐시
    - 게이트웨이
        + 다른 서버들의 중개자로 동작하는 서버
        + HTTP 트래픽을 다른 프로토콜로 변환
### URL과 리소스
+ **URL(Uniform Resource Locator)**
    + 인터넷의 리소스를 가리키는 표준이름
    + 웹 브라우저가 정보를 찾는데 필요한 리소스의 위치를 가리킴
    
+ **URL의 구조**
    + `스킴://서버위치/경로` 구조로 이루어져 있다.
    + 이러한 구조를 가지게되면서 브라우저가 더 영리하게 리소스에 접근하고 다룰 수 있게 되었다.

+ **URL 문법**
    + 필자의 깃 주소를 예를 들면
        + > https://github.com/yondo123/
            + 스킴 : 어떤 프로토콜을 사용할 것인지? → https
                + 스킴은 대소문자를 가리지 않는다.
            + 사용자 이름 : 보통 `ftp` 프로토콜에서 사용한다 (기본 값 : anonymous)
            + 호스트 : 리소스를 호스팅하는 서버의 호스트명 또는 IP 주소 → github.com
            + 포트 : 호스팅하는 서버가 열어놓은 포트번호  → 깃허브 https의 기본 포트번호는 443이다. (http는 80)
            + 경로 : 서버 내 리소스가 어디에 있는지?  → /yondo123
            + 질의어 : 요청받은 리소스 형식의 범위를 좁히기 위해 사용
                > /search/all?frm=NVSHPRC&maxPrice=40000&minPrice=20000&minPrice-maxPrice=20000-40000 (흔한 쇼핑몰 질의 방식)
            + 보통 '&'로 구분하여 `'key=value'` 형식으로 많이 사용한다. 
    
    + **URL 확장**
    + 브라우저 마다 URL을 입력한 다음 자동으로 URL을 확장(생성) 해주는 기능
    1. 호스트명 확장
        + 호스트명만 입력하면 자동으로 'www'와 'com'을 붙여서 URL을 생성한다.
    2. 히스토리 확장
        + 사용자가 과거에 방문했던 URL의 기록을 저장하고 자동으로 URL을 선택해주게 하는 것

+ **안전한 전송**
    + 정보가 유실될 위험 없이 URL을 전송할 수 있다.
    + RFC 2396 (URI 포맷 정의 기관)에서는 어플리케이션이 공백을 무시하기를 권고하고 있다.
    + **인코딩 체계**
        - URL에 있는 안전하지 않은 문자들을 표현할 수 있는 인코딩 방식 고안
        - 안전하지 않은 문자를 '%'기호 + ASCII코드의 16진수 이스케이프 문자를 합쳐 바꾼다.
            | Char | ASCII | URL |
            | ------ | ----------- | ------| 
            | ~ | 26(0x7E) | /%7E |
            | 공백 | 32(0x20) | /%20 |
            | % | 37(0x25) | /%25 |
    
+ **문자 제한**
    + URL에서 흔히 사용하는 문자(예약어)를 본래의 용도가 아닌 다른 용도로 사용하는 경우, 반드시 인코딩 해야 한다.
        | Char | 제한 |
        | --- | --- |
        | % | 인코딩된 문자에 사용할 이스케이프 토큰 |
        | / | 경로 컴포넌트에있는 경로 세그먼트를 나누는 용도 |
        | . | 경로 컴포넌트 |
        | .. | 경로 컴포넌트 |
        | # | 프래그먼트의 구획 문자 |
        | ? | 질의 문자열의 구획 문자  |
        | ; | 파라미터의 구획 문자 |
        | : | 스킴, 사용자이름/비밀번호, 호스트/포트의 구획 문자 |
        | $, + | 선점 |
        | @ & = | 특정 스킴에서 특별한 의미가 있음 |
        | {} `|`\ · ~ [] ` | 게이트웨이와 같은 여러 전송 에이전트에서 불안전하게 다루기 때문에 제한 |
        | <> " | URL을 구분지어 표시하듯이 URL 범위 밖에서 역할이 있는 문자이기 때문에 제한 |
        | 0x00-0x1F, 0x7F | US-ASCII에서 인쇄되지 않는 문자 범위 |
        | > 0x7F | 7비트의 US-ASCII 문자가 아니기 떄문에 제한 |
### HTTP 메시지
+ **인바운드와 아웃바운드**
    + 인바운드 : 메시지가 원 서버로 향하는 것
    + 아웃바운드 : 모든 처리가 끝난 후 사용자에게 다시 돌아오는 것
    + 메시지는 `원 서버 방향으로(인바운드)` 송신된다.
    
+ **메시지의 구성**
    + 시작줄, 헤더, 메시지(본문, 엔티티)로 구분된다.
    + 메시지 본문은 단순히 선택적인 데이터 덩어리이다.
    + 비어져있을 수 있고, 이진 데이터를 포함할 수 있다.

+ **메시지 문법**
    + HTTP 요청/응답 메시지 형태는 다음과 같다.
    + `시작줄 - 헤더 - 본문`으로 구성되어 있다.
        ```
                -Request 
                <Method> <요청 URL> <version>
                <header>
                <context>

                -Response
                <version> <status> <status comment>
                <header>
                <context>
        ```
    + 요청 URL
        + 요청 대상의 리소스 주소를 가리킨다.
        + URL에서 호스트/포트가 생략되면 서버에서 자기 자신으로 간주하고 통신한다.
    + 본문(context)
        + 임의의 데이터 블록, 선택사항이므로 만약 없다면 메시지는 CRLF으로 끝나게 된다.
        + 요청 메소드에 따라 본문이 필요할수도, 필요없을수도 있다.
    + 헤더
        + 애플리케이션 마다 자유롭게 자신만의 헤더를 만들어낼 수 있다.
    
+ **요청 메소드**
    | Method | Description | Text Y/N  | Remark |
    | ------ | ----------- | --|----|
    | GET    | 서버에서 어떤 문서(리소스)를 가져온다. | N | |
    | HEAD   | 서버에서 어떤 문서(리소스)에서 헤더만 가져온다. | N | 동작은 GET과 동일 |
    | POST   | 서버에서 처리해야 할 데이터를 보낸다.  | Y |  |
    | PUT    | 서버에 요청 메시지의 본문을 저장한다. | Y | 요청 본문이 없다면 리소스를 생성, 존재한다면 기존 리소스 수정 | 
    | TRACE  | 요청 메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적한다. | N | 진단을 위해 사용 |
    | OPTIONS| 서버가 어떤 메소드를 수행할 수 있는지 확인한다. | N | |
    | DELETE | 서버에서 문서를 제거한다. | N | 서버는 클라이언트에 통보하지 않고 요청을 무시 가능 |

+ **상태 코드**
    + 정보성 상태 코드 (100 ~ 199)
        + HTTP 1.1에서 도입
        + 100 : Continue (요청 받아들여짐)
        + 101 : Switching Protocols (서버가 프로토콜을 변경)

    + 성공 상태 코드 (200 ~ 299)
        | Status | Text | Description |
        | ---- | ---- | ---- |
        | 200  | OK | 정상요청, 요청한 리소스를 가지고 있다. |
        | 201  | Created | PUT 요청, 생성된 리소스에 대한 구체적 참조 메시지 필요 | 
        | 202 | Accepted | 요청은 받아들여졌으나, 서버 측에서 어떠한 동작도 수행하지 않음 |
        | 203 | Non-Authoritative Information | 중개자가 사본을 갖고 있지만 리소스에 대한 정보 검증 부족 |
        | 204 | No Content | 헤더와 상태줄은 포함하지만 본문을 포함하지 않을 때 (클라이언트에게 전송 할 데이터가 없음) |
        | 205 | Recent Content | 브라우저를 위한 코드, 현재 페이지에 있는 HTML 폼을 비우라는 요청 |
        | 206 | Partial Content | 부분 또는 범위 요청 성공 | 
        
    + 리다이렉션 상태 코드 (300 ~ 399)
        + 클라이언트가 요청하는 리소스에 대해 다른 위치를 제시하거나, 대안 응답을 제공한다.
        
    + 클라이언트 - 에러 상태 코드 (400 ~ 499)
        | Status | Text | Description |
        | ---- | ---- | ---- |
        | 400  | Bad Request | 잘못된 요청을 전송 |
        | 401  | Unauthorized | 리소스를 얻기전에 클라이언트에게 인증 요청 |
        | 402 | Payment Required  | 현재 사용안함 |
        | 403 | Forbidden | 서버에 의해 요청이 거부됨 |
        | 404 | Not Found | 요청한 URL을 서버가 찾을 수 없음 |
        | 405 | Method Not Allowed | 요청한 메소드에 대해 서버가 지원하지 않음 |
        | 408 | Request Timeout | 클라이언트 요청을 완수하기에 너무 시간이 길 경우 |

    + 서버 - 에러 상태 코드 (500 ~ 599)
        | Status | Text | Description |
        | ---- | ---- | ---- |
        | 500 | Internal Server Error | 서버가 요청을 처리할 수 없음 |
        | 501 | Not Implemented | 클라이언트가 서버가 지원하지 않는 메소드를 사용 (능력범위이상) |
        | 502 | Bad Gateway | 프락시나 게이트웨이처럼 행동하는 서버가 다음 링크로부터 가짜 응답에 맞닥뜨렸을 때 |
        | 503 | Service Unavailable | 현재는 서버가 처리할 수 없지만 추후 가능함 |
        | 504 | Gateway Timeout | 상태코드 '408'과 유사하지만, 다른 서버에게 요청을 보내고 응답을 기다리다 Timeout이 발생 (게이트웨이 또는 프락시에서 응답)|
        | 505 | HTTP Version Not Supported | 서버가 지원할 수 없거나 지원하지 않으려고하는 프로토콜 버전을 요청 받았을 때 |

### 커넥션 관리
+ **TCP 커넥션**
    + 모든 HTTP 통신은 `TCP/IP` 프로토콜을 통해 이루어진다.
    + 클라이언트 애플리케이션과 서버 애플리케이션은 언제 어디서든, TCP/IP 커넥션을 맺을 수 있다. 한번 맺어지면 메시지들은 손상되지 않고 올바르게 전달된다.

+ **HTTP와 HTTPS 네트워크 프로토콜**
    ![HTTPS/HTTP](https://user-images.githubusercontent.com/46988995/90979136-f1e9c400-e58d-11ea-89a8-c5be8e8edbaf.jpg)
    + HTTP가 메시지를 전달할 경우, TCP 커넥션을 통해 메시지 데이터를 순서대로 보내고 세그먼트라는 단위로 데이터 스트림을 분할 -> 세그먼트들을 패킷 단위로 인터넷을 통해 데이터를 전송한다.

+ **TCP 커넥션 유지**
    + TCP 커넥션의 식별 방법
        > <발신지 IP, 발신지 PORT, 수신지 IP, 수신지 PORT>
        + 네가지 커넥션 구성요소가 완전히 동일한 커넥션은 있을 수 없다.
    
+ **TCP 커넥션 성능 지연 요소**
    + TCP 커넥션의 핸드셰이크 설정
        + 커넥션을 새로 맺을 때 마다 SYN+ACK 플래그 값들의 핸드셰이크 지연이 발생한다.
    + TCP의 느린 시작 (slow-start)
        + TCP 커넥션은 시간이 흐를수록(데이터 교환) 전송 성공률에 따라 전송 속도를 높여나간다. 즉, 새로 맺은 커넥션보다 이미 연결중인 커넥션 속도가 더빠르며 커넥션 재사용을 통해 이 문제를 해결할 수 있다.
    + 네이글(nagle) 알고리즘
        + 크기가 작은 메시지는 최소 패킷을 채우지 못해 추가적인 데이터를 기다리며 지연될 것이다.

+ **커넥션 끊기**
    + HTTP 메시지는 클라이언트에서 서버로 전송하기 까지 많은 중개자 서버를 하나하나 거치면서 전송된다.

    + HTTP 커넥션 헤더 필드는 쉼표로 구분하고 있고 현재 맺고 있는 커넥션에서만 적용하는 옵션을 명시할 수 있다.
        + `Connection: close` 옵션은 메시지를 전송하고 즉시 종료하라는 의미의 옵션 값이다.

+ **커넥션 종류**
    + 순차 커넥션
        + 각 트랜잭션이 새로운 커넥션을 맺는 방식으로 새로운 커넥션을 맺을 때 마다 맺는데 발생하는 지연과 slow-start 지연이 발생하는 문제가 있다.
        + 이를 해결하기 위해 병렬, 지속, 파이프라인, 다중 커넥션 등의 성능 향상 기법이 있다.

    + 병렬 커넥션
        + 여러개의 HTTP 트랜잭션을 병렬적으로 처리하는 기법으로 커넥션 지연 시간을 겹치게해 더욱 빠르게 서버의 리소스를 로드할 수 있다.
        + 사실 리소스(웹 페이지)를 더 빠르게 로드하지 않더라도, 사용자에게는 동시에 여러 리소스를 받아오는 것을 보이게하면서 '더 빠르게' 느껴보이는 효과가 있다. 
        + 순차 커넥션보다 일반적으로 빠르긴 하지만, 항상 빠른것은 아니다, 클라이언트의 네트워크 대역폭이 좁을 때는 제한된 대역폭 내에서 각각 리소스를 전송받는 것은 느리기 때문에 성능상의 장점이 없는셈이다.
    
    + 지속 커넥션
        + 보통 한 웹 사이트에서 사용하는 자원은 한정적이어서 대부분의 리소스는 같은 공간(서버)를 가리킨다. 따라서 한 서버에 HTTP 통신을 요청한 애플리케이션은 동일한 서버에 요청 할 가능성이 크다.
        (이를 사이트 지역성, site locality라 부른다.)
        비 지속 커넥션은 각 처리(트랜잭션)이 끝날 때마다 커넥션을 끊고 새로 연결을 맺지만, 지속 커넥션은 클라이언트나 서버에서 끊기 전까지 트랜잭션 간에도 커넥션을 유지한다. 항상 서버에 이미 맺어진 커넥션을 재사용함으로써, 커넥션을 맺는데 걸리는 지연시간을 최소화할 수 있다.
        + HTTP/1.1에서는 커넥션을 맺으면 기본적으로 지속 커넥션으로 유지한다.
    
    + 파이프라인 커넥션
        + HTTP/1.1에서는 지속 커넥션을 이용해 요청을 파이프라이닝할 수 있다. 여려개의 요청은 응답이 도착하기 전 까지 큐에 쌓이고, 첫 요청이 서버측에 전달되면 연이어 두 번째, 세 번째 요청이 전달되는 방식이다. 이는 대기시간이 긴 네트워크 상황 속에서 왕복 지연 시간을 줄여 성능을 높여준다.

## 2. HTTP 아키텍처
### 웹서버
+ **웹서버가 하는일**
    + 커넥션 맺기
    + 요청받기 및 요청처리
    + 리소스 접근
    + response 생성 및 전송(올바른 헤더)
    + 로그파일 기록

